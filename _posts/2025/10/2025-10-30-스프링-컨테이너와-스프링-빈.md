---
title: "스프링 컨테이너와 스프링 빈"
categories: [ "Java & Spring" ]
tags: [ "[인프런] 스프링 핵심 원리" ]
date: "2025-10-30 21:01:00"
---

## 스프링 컨테이너 생성

```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```

- `ApplicationContext`를 스프링 컨테이너라 함
- `ApplicationContext`는 인터페이스이다.
- 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 어노테이션 익반의 자바 설정 클래스로 만들 수 있음

### 스프링 컨테이너의 생성 과정

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/265597505979625.png)

- 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 함
- 여기서는 `AppConfig.class`를 구성 정보로 지정했음

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/265640210157291.png)

- 빈 이름은 메서드 이름을 사용
- 빈 이름을 직접 부여할 수도 있음
  - `@Bean(name = "memberService2")`

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/265684208835333.png)
![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/265694520548666.png)

- 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입한다.

## 컨테이너에 등록된 모든 빈 조회

```java
public class ApplicationContextInfoTest {

  AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);

  @Test
  @DisplayName("모든 빈 출력하기")
  void findAllBean() {
    String[] beanDefinitionNames = ac.getBeanDefinitionNames();
    for (String beanDefinitionName : beanDefinitionNames) {
      Object bean = ac.getBean(beanDefinitionName);
      System.out.println("name = " + beanDefinitionName + " object = " + bean);
    }
  }

  @Test
  @DisplayName("애플리케이션 빈 출력하기")
  void findApplicationBean() {
    String[] beanDefinitionNames = ac.getBeanDefinitionNames();
    for (String beanDefinitionName : beanDefinitionNames) {
      BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName);

      // Role ROLE_APPLICATION: 직접 등록한 애플리케이션 빈
      // Role ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하는 빈
      if (beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION) {
        Object bean = ac.getBean(beanDefinitionName);
        System.out.println("name = " + beanDefinitionName + " object = " + bean);
      }
    }
  }
}
```

## 스프링 빈 조회

### 기본

```java
public class ApplicationContextSameBeanFindTest {

  AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class);

  @Test
  @DisplayName("타입으로 조회 시, 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.")
  void findBeanByType() {

    Assertions.assertThrows(NoUniqueBeanDefinitionException.class, () -> ac.getBean(MemberRepository.class));
  }

  @Test
  @DisplayName("타입으로 조회 시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.")
  void findBeanByName() {
    MemberRepository memberRepository = ac.getBean("memberRepository1", MemberRepository.class);
    assertThat(memberRepository).isInstanceOf(MemberRepository.class);
  }

  @Test
  @DisplayName("특정 타입을 모두 조회하기")
  void findAllBeanByType() {
    Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);
    for (String key : beansOfType.keySet()) {
      System.out.println(key + " = " + key + " value " + beansOfType.get(key));
    }
    System.out.println("beansOfType = " + beansOfType);
    assertThat(beansOfType.size()).isEqualTo(2);
  }

  @Configuration
  static class SameBeanConfig {

    @Bean
    public MemberRepository memberRepository1() {
      return new MemoryMemberRepository();
    }

    @Bean
    public MemberRepository memberRepository2() {
      return new MemoryMemberRepository();
    }

  }
}
```

### 동일한 타입이 둘 이상

```java
public class ApplicationContextSameBeanFindTest {

  AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class);

  @Test
  @DisplayName("타입으로 조회 시, 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.")
  void findBeanByType() {

    Assertions.assertThrows(NoUniqueBeanDefinitionException.class, () -> ac.getBean(MemberRepository.class));
  }

  @Test
  @DisplayName("타입으로 조회 시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.")
  void findBeanByName() {
    MemberRepository memberRepository = ac.getBean("memberRepository1", MemberRepository.class);
    assertThat(memberRepository).isInstanceOf(MemberRepository.class);
  }

  @Test
  @DisplayName("특정 타입을 모두 조회하기")
  void findAllBeanByType() {
    Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);
    for (String key : beansOfType.keySet()) {
      System.out.println(key + " = " + key + " value " + beansOfType.get(key));
    }
    System.out.println("beansOfType = " + beansOfType);
    assertThat(beansOfType.size()).isEqualTo(2);
  }

  @Configuration
  static class SameBeanConfig {

    @Bean
    public MemberRepository memberRepository1() {
      return new MemoryMemberRepository();
    }

    @Bean
    public MemberRepository memberRepository2() {
      return new MemoryMemberRepository();
    }

  }
}
```

### 상속 관계

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/265950436621083.png)

- 부모 타입으로 조회하면, 자식 탙입도 함께 조회 됨
- 그래서 Object로 조회 시, 모든 스프링 빈이 조회 됨

## BeanFactory와 ApplicationContext

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/266026360352625.png)

### BeanFactory

- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할을 담당
- `getBean()`을 제공

### ApplicationContext

- `BeanFactory` 기능을 모두 상속 받아서 제공
- 빈 관리 기능 + 편리한 부가 기능 제공

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/266123853142000.png)

- 메시지소스를 활용한 국제화 기능
- 환경변수
- 애플리케이션 이벤트
- 편리한 리소스 조회

## 다양한 설정 형식 지원 - 자바 코드. XML

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/266176657657916.png)

### 어노테이션 기반 가바 코드 설정 사용

- `new AnnotationConfigApplicationContext(AppConfig.class)`

### XML 설정 사용

> xml 기반으로 설정하는 것은 ㅗ치근에는 잘 사용하지 않습니다.

```java
public class XmlAppContext {

  @Test
  void xmlAppContext() {

    GenericXmlApplicationContext ac = new GenericXmlApplicationContext("appConfig.xml");

    MemberService memberService = ac.getBean("memberService", MemberService.class);
    assertThat(memberService).isInstanceOf(MemberService.class);

  }
}
```

- **src/main/resources/appConfig.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="memberService" class="com.abcdejoji.springbaisc.member.MemberServiceImpl">
    <constructor-arg name="memberRepository" ref="memberRepository"/>
  </bean>

  <bean id="memberRepository" class="com.abcdejoji.springbaisc.member.MemoryMemberRepository"/>

  <bean id="orderService" class="com.abcdejoji.springbaisc.order.OrderServiceImpl">
    <constructor-arg name="memberRepository" ref="memberRepository"/>
    <constructor-arg name="discountPolicy" ref="discountPolicy"/>
  </bean>

  <bean id="discountPolicy" class="com.abcdejoji.springbaisc.discount.RateDiscountPolicy"/>
</beans>
```

## 스프링 빈 설정 메타 정보 - BeanDefinition

![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/266345113292333.png)
![](/assets/img/_posts/2025/10/2025-10-30-스프링-컨테이너와-스프링-빈/266401119896333.png)

- `AnnotationConfigApplicationContext`는 `AnnotatedBeanDefinitionReader`를 사용해서 `AppConfig.class`를 읽고 `BeanDefinition`을 생성
- `GenericXmlApplicationContext`는 `XmlBeanDefinitionReader`를 사용해서 `appConfig.xml` 설정 정보를 읽고 `BeanDefinition`을 생성

### BeanDefinition 삺펴보기

- `BeanClassName`: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
- `factoryBeanName`: 팩토리 역할의 빈을 사용할 경우 이름
  - 예) `appConfig`
- 빈을 생성할 팩토리 메서드 지정
  - 예) `memberService`
- `Scope`: 싱글톤(기본값)
- `lazyInit`: 스프링 컨테이너를 생성할 떄 빈을 생성하는 것이 아니라, 실제 빈을 사용할 떄 까지 최대한 생성을 지연처리 하는지 여부
- `InitMethodName`: 빈을 생성하고, 의존 관계를 적용한 뒤에 호출되는 초기화 메서드 명
- `DestroyMethodName`: 빈의 생명 주기가 끝나서 제거하기 직전에 호출되는 메서드 명
- `Constructor arguments`, `Properties`: 의존 관계 주입에서 사용(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

## 참고

- [https://www.inflearn.com/course/스프링-핵심-원리-기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)
