---
title: "논리적 모델링 - 식별 관계, 비식별 관계"
categories: [ "DB" ]
tags: [ "[인프런] 김영한의 실전 데이터베이스 - 설계1편", "RDBMS" ]
date: "2025-10-12 23:02:00"
---

## 식별 관계 vs 비식별 관계 - 개념

- 테이블 간의 관계는 `외래 키(FK)`를 `기본 키(PK)`의 일부로 사용하느냐에 따라 식별 관계와 비식별 관계로 나뉨
- **식별 관계**
  - 부모 테이블의 `PK`를 자식 테이블의 `PK + FK`로 사용
  - 뷰모 없이는 자식이 삭별될 수 없는 강한 관계
- **비식별 관계**
  - 부모 테이블의 `PK`를 자식 테이블의 `일반 컬럼 + FK`로만 사용
  - 자식은 자신만의 고유한 `PK`를 가짐
  - 부모와 독립적으로 존재할 수 있는 약한 관계

## 식별 관계 vs 비식별 관계 - 일대다(1:N)

- **비식별 관계**
  - 자식 테이블이 독립적인 PK(대리 키)를 가져 구조가 단순하고 명확
  - 관계 변경에 유연
  - ORM 기술과 친화적
- **식별 관계**
  - 부모 `PK`를 포함한 복합키를 자식의 `PK`로 사용
  - `PK`자체가 비즈니스 의미를 가지지만, 복합키는 관리하기 복잡하고 유연성과 확장성이 떨어짐

## 식별 관계의 문제점

- **유연성 부족**
  - PK로 강하게 결합되어 있어, 데이터의 소속을 변경하는 등 비즈니스 요구사항 변경에 대응하기 매우 어려움
  - PK 값 자체를 수정해야 하는 문제가 발생
- **PK 컬럼의 전파**
  - 부모 - 자식 - 손자 관계로 계층이 깊어질수록 부모의 PK가 누적되어 손자 테이블의 PK가 매우 길고 복잡해 짐
  - 이는 SQL 쿼라와 JOIN, ORM 매핑을 어렵게 만듦
- 현대 애플리케이션 개발에서는 유연성과 확장성을 위해 **비식별 관계와 대리 키 사용을 원칙**으로 함

## 식별 관계 vs 비식별 관계 - SQL 쿼리, 성능

- **쿼리 단순성**: 비식별 관계는 단일 `PK`를 사용하므로 조회 조건이 단순하며 이는 API 설계, 개발 편의성, ORM과의 조합에서 큰 이점을 가짐
- **인덱스 성능**: 식별 관계는 복합 `PK`인덱스 덕분에 특정 조회에서 별도 인덱스 없이 효율적일 수 있음
- **결론**: 비식별 관계에서 FK에 인덱스를 추가하는 것은 간단. 사소한 인덱스 최적화 이점을 위해 설뎨 전체의 유연성을 희생하는 것은 바람직하지 않음

## 식별 관계 vs 비식별 관계 - 일대일(1:1)

- **비식별 관계**
  - 자식 테이블이 독립적인 `PK`를 가지며, 1:1 관계 보장을 위해 FK에 `UNIQUE` 제약조건을 추가
  - 테이블 간의 결합도가 낮아 유연하고 확장성이 좋음
- **식별 관계**
  - 자식 테이블이 부모의 `PK`를 자신의 `PK`이자 `FK`로 사용
  - 구조적으로 강한 결합을 표현하지만, 유연성이 낮음
- 향후 관계가 1:N으로 변경 될 사능성을 고려 할 때, 제약 조건만 제거하면 되는 비식별 관계가 테이블 구조를 변경해야 하는 식별 관계보다 훨씬 유리

## 식별 관계 vs 비식별 관계 - 다대다(M:N)

- 식별 관계
  - 양쪽 부모의 `PK`를 조합한 복합키를 사용
  - `PK` 자체가 하나의 주문에 동일 상품 중복 불가와 같은 비즈니스 규칙을 강제하지만, 규칙 변경 시 `PK`를 수정해야 해 확장성이 매우 낮음
- 비식별 관계
  - 독립적인 `PK(대리 키)`를 사용
  - 비즈니스 규칙은 `FK` 조합에 `UNIQUE` 제약조건을 추가하여 보장
  - 유연성과 데이터 정합성을 모두 확보할 수 있어 가장 권장되는 방식

## 식별 관계 vs 비식별 관계 - 현대적인 설계 트렌드

- 현대적인 DB 설계에서는 **비식별 관게를 사용하는 것이 사실상 표준**
- **이유**
  - 압도적인 유연성
  - 구조의, 단순성과 일관성
  - ORM 기술과의 친화성
  - 비즈니스 로직과의 분리 등
  - 변화에 민첩하게 대응해야하는 현대 소프트웨어의 가치와 부합

## 설계의 황금룰

- **PK**: 대리 키
- **관계**: 비식별 관계
- **규칙**: 비즈니스적 중복 방지는 UNIQUE 제약조건으로 해결

## 참고

- [https://www.inflearn.com/course/김영한-실전-데이터베이스-설계1편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C-%EC%8B%A4%EC%A0%84-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%A4%EA%B3%841%ED%8E%B8)
