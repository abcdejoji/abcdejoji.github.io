---
title: "싱글톤 컨테이너"
categories: [ "Java & Spring" ]
tags: [ "[인프런] 스프링 핵심 원리" ]
date: "2025-10-31 12:04:00"
---

## 웹 애플리케이션과 싱글톤

- 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
- 이떄, 매 요청마다 새로운 객체를 생성하여 반환하면 메모리 낭비가 심함
- 해결방안은 해당 객체를 1개만 생성되고, 공유되도록 설계하면 됨 -> 싱글톤 패턴

## 싱글톤 패턴

- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 함

```java
public class SingletonService {

  // 1. static 영역에 객체를 딱 1개만 생성
  private static final SingletonService instance = new SingletonService();

  // 2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용
  public static SingletonService getInstance() {
    return instance;
  }

  // 3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생상을 못하게 막음
  private SingletonService() {
  }
}
```

### 싱글톤 패턴 문제점

- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어감
- 의존 관계상 클라이언트가 구체 클래스에 의존 -> DIP 위반
- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높음
- 테스트하기 어려음
- 내부 속성을 변경하거나 초기화 하기 어려움
- `private` 생성자로 자식 클래스를 만들기 어려움
- 결론적으로 유연성이 떨어짐
- 안티패턴으로 불리기도 함

## 싱글톤 컨테이너

- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 함
  - 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 핢
- 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있음
  - 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 됨
  - `DIP`, `OCP`, `테스트`, `private` 생성자로 부터 자유롭게 싱글톤을 사용할 수 있음

## 싱글톤 방식의 주의점

- 싱글톤 방식은 여러 클라이언트가 하나의 같은 개체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안됨
- 무상태(stateless)로 설계해야 함
  - 특정 클라이언트에 의존적인 필드가 있으면 안됨
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됨
  - 가급적 읽기만 가능해야 함
  - 필드 대신에 자바에서 공유되지 않는, `지역변수`, `파라미터`, `ThreadLocal` 등을 사용해야 함

## @Configuration과 싱글톤

```java

@Configuration
public class AppConfig {

  @Bean
  public MemberService memberService() {
    System.out.println("AppConfig.memberService");
    return new MemberServiceImpl(memberRepository());
  }

  @Bean
  public MemoryMemberRepository memberRepository() {
    System.out.println("AppConfig.memberRepository");
    return new MemoryMemberRepository();
  }

  @Bean
  public OrderService orderService() {
    System.out.println("AppConfig.orderService");
    return new OrderServiceImpl(
      memberRepository(),
      discountPolicy()
    );
  }

  @Bean
  public DiscountPolicy discountPolicy() {
    //        return new FixDiscountPolicy();
    return new RateDiscountPolicy();
  }
}
```

위 코드는 `memberRepository`는 총 3번 생성되는 것 처럼 보입니다.

- `memberRepository`를 만들때 한 번
- `memberService`를 만들때 한 번
- `orderService`를 만들때 한 번

```bash
AppConfig.memberService
AppConfig.memberRepository
AppConfig.orderService
```

하지만 실제로 실행 시켜보면 `memberRepository`는 한 번만 호출됩니다.

## @Configuration과 바이트코드 조작의 마법

`@Configuration`이 붙은 클래스는 `CGLIB` 라이브러리를 사용하여 바이트코드를 조작하여 프록시 객체를 생성합니다.

```bash
class com.abcdejoji.springbaisc.AppConfig$$SpringCGLIB$$0
```

### 프록시 객체 예상 코드

```java
public MemberRepository memberRepository() {
  if (memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있으면 ?){
    return 스프링 컨테이너에서 찾아서 반환;
  } else{ //스프링 컨테이너에 없으면
    기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록
    return 반환;
  }
}
```

- 스프링 컨테이너에 이미 존재하면 해당 객체를 반환
- 없다면 생성하여 기존 로직 호출하여 생성 후 스프링 컨테이너에 등록 후 반환

### @Configuration을 적용하지 않고, @Bean만 적용하는 경우

```bash
AppConfig.memberService
AppConfig.memberRepository
AppConfig.memberRepository
AppConfig.orderService
AppConfig.memberRepository
```

예상한 대로 `memberRepository`를 3번 호출합니다.

## 참고

- [https://www.inflearn.com/course/스프링-핵심-원리-기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)
