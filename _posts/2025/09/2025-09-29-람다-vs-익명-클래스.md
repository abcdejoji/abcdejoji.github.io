---
title: "람다 vs 익명 클래스"
categories: [ "Java & Spring" ]
tags: [ "[인프런] 김영한의 실전 자바 - 고급 3편" ]
date: "2025-09-29 21:33:00"
---

## 문법 차이

### 익명 클래스

```java
// 익명 클래스 사용 예
void main() {
  Button button = new Button();
  button.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick (View v){
      System.out.println("버튼 클릭");
    }
  });  
}

```

### 람다 표현식

```java
// 람다 표현식 사용 예
void main() {
  Button button = new Button();
  button.setOnClickListener(v -> System.out.println("버튼 클릭"));
}

```

## 코드 간결함

- 익명 클래스
  - 문법적으로 더 복잡하고 장황
  - `new 인터페이스명()` 같은 형태와 함께 메서드를 오버라이드해야 하므로 코드이, 양이 상대적ㅇ로 만흠
- 람다 표현식
  - 간결하며, 불필요한 코드를 최소화
  - 많은 생략 기능을 지원해서 핵심 코드만 작성할 수 있음

## 상속 관계

- 익명 클래스: 일반적인 클래스처럼 다양한 인터페이스와 클래스를 구현하거나 상속할 수 있음
- 람다 표현식: 메서드를 딱 하나만 가지는 함수형 인터페이스만을 구현할 수 있음

## 호환성

- 익명 클래스: 오래된 버전에서도 사용할 수 있음
- 람다 표현식: 자바 8이후 부터 사용할 수 있음

## this 키워드

- 익명 클래스: 내부에서 `this`는 익명 클래스 자기 자신을 가리킴
- 람다 표현식: `this`는 람다를 선언한 클래스의 인스턴스를 가리킴

## 캡처링(Capturing)

- 둘 다 외부 변수에 접근 할 수 있지만, 지역 변수는 반드시 `final` 혹은 사실상 `final`인 변수만 캡처할 수 있음

## 생성 방식

- 익명 클래스
  - 컴파일시 실제로 클래스 파일이 생성
  - 일반적인 클래스와 같은 방식으로 작동
  - 해당 클래스 파일을 JVM에 불러서 사용하는 과정이 필요
- 람다
  - 컴파일 시점에 클래스 파일이 생성되지 않음
    - 내부적으로 `invokeDynamic`이라는 메커니즘을 사용하여 컴파일 타임에 실제 클래스 파일을 생성하지 않고, 런타임 시점에서 동적으로 필요한 코드를 처리
  - 자바를 실행하는 실행 시점에 동적으로 필요한 코드를 처리

## 상태 관리

- 익명 클래스
  - 인스턴스 내부에 상태(필드, 멤버 변수)를 가질 수 있음
- 람다
  - 내부에 상태(피드)를 가지지 않고 기능만 제공
  - 필드가 없으므로 스스로 상태를 유지하지는 않음

## 익명 클래스와 람다의 용도 구분

- 익명 클래스
  - 상태를 유지하거나 다중 메서드를 구현할 필요가 있는 경우
  - 기존 클래스 또는 인터페이스를 상속하거나 구현할 때
  - 복잡한 인터페이스 구현이 필요할 때
- 람다
  - 상태를 유지할 필요가 없고, 간결함이 중요한 경우
  - 단일 메서드만 필요한 간단한 함수형 인터페이스 구현 시
  - 더 나은 성능(미미함)과 간결한 코드가 필요한 경우

## 참고

- [https://www.inflearn.com/course/김영한의-실전-자바-고급-3](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-3)
